package gameboy

import (
	"fmt"

	"golang.org/x/xerrors"
)

// TODO(velovix): Document what instructions do to flags

// instruction is a function that runs microcode for a CPU instruction and may
// return either another instruction function for the next microcode or nil
// indicating that the instruction has finished. Each microcode takes 4 CPU
// cycles to complete.
type instruction func(*State) int

// opcodeMapper is a lookup table that links opcodes to the corresponding
// instructions.
var opcodeMapper = []instruction{
	0x00: nop,
	0x01: makeLD16BitImm(regBC),
	0x02: makeLDToMem(regBC, regA),
	0x03: makeINC16Bit(regBC),
	0x04: makeINC8Bit(regB),
	0x05: makeDEC8Bit(regB),
	0x06: makeLD8BitImm(regB),
	0x07: rlca,
	0x08: ldSPToMem,
	0x09: makeADDToHL(regBC),
	0x0A: makeLDFromMem(regA, regBC),
	0x0B: makeDEC16Bit(regBC),
	0x0C: makeINC8Bit(regC),
	0x0D: makeDEC8Bit(regC),
	0x0E: makeLD8BitImm(regC),
	0x0F: rrca,
	0x10: stop,
	0x11: makeLD16BitImm(regDE),
	0x12: makeLDToMem(regDE, regA),
	0x13: makeINC16Bit(regDE),
	0x14: makeINC8Bit(regD),
	0x15: makeDEC8Bit(regD),
	0x16: makeLD8BitImm(regD),
	0x17: rla,
	0x18: jr,
	0x19: makeADDToHL(regDE),
	0x1A: makeLDFromMem(regA, regDE),
	0x1B: makeDEC16Bit(regDE),
	0x1C: makeINC8Bit(regE),
	0x1D: makeDEC8Bit(regE),
	0x1E: makeLD8BitImm(regE),
	0x1F: rra,
	0x20: makeJRIfFlag(zeroFlag, false),
	0x21: makeLD16BitImm(regHL),
	0x22: makeLDIToMem,
	0x23: makeINC16Bit(regHL),
	0x24: makeINC8Bit(regH),
	0x25: makeDEC8Bit(regH),
	0x26: makeLD8BitImm(regH),
	0x27: daa,
	0x28: makeJRIfFlag(zeroFlag, true),
	0x29: makeADDToHL(regHL),
	0x2A: ldiFromMem,
	0x2B: makeDEC16Bit(regHL),
	0x2C: makeINC8Bit(regL),
	0x2D: makeDEC8Bit(regL),
	0x2E: makeLD8BitImm(regL),
	0x2F: cpl,
	0x30: makeJRIfFlag(carryFlag, false),
	0x31: makeLD16BitImm(regSP),
	0x32: makeLDDToMem,
	0x33: makeINC16Bit(regSP),
	0x34: incMemHL,
	0x35: decMemHL,
	0x36: makeLD8BitImmToMemHL,
	0x37: scf,
	0x38: makeJRIfFlag(carryFlag, true),
	0x39: makeADDToHL(regSP),
	0x3A: lddFromMem,
	0x3B: makeDEC16Bit(regSP),
	0x3C: makeINC8Bit(regA),
	0x3D: makeDEC8Bit(regA),
	0x3E: makeLD8BitImm(regA),
	0x3F: ccf,
	0x40: makeLD(regB, regB),
	0x41: makeLD(regB, regC),
	0x42: makeLD(regB, regD),
	0x43: makeLD(regB, regE),
	0x44: makeLD(regB, regH),
	0x45: makeLD(regB, regL),
	0x46: makeLDFromMem(regB, regHL),
	0x47: makeLD(regB, regA),
	0x48: makeLD(regC, regB),
	0x49: makeLD(regC, regC),
	0x4A: makeLD(regC, regD),
	0x4B: makeLD(regC, regE),
	0x4C: makeLD(regC, regH),
	0x4D: makeLD(regC, regL),
	0x4E: makeLDFromMem(regC, regHL),
	0x4F: makeLD(regC, regA),
	0x50: makeLD(regD, regB),
	0x51: makeLD(regD, regC),
	0x52: makeLD(regD, regD),
	0x53: makeLD(regD, regE),
	0x54: makeLD(regD, regH),
	0x55: makeLD(regD, regL),
	0x56: makeLDFromMem(regD, regHL),
	0x57: makeLD(regD, regA),
	0x58: makeLD(regE, regB),
	0x59: makeLD(regE, regC),
	0x5A: makeLD(regE, regD),
	0x5B: makeLD(regE, regE),
	0x5C: makeLD(regE, regH),
	0x5D: makeLD(regE, regL),
	0x5E: makeLDFromMem(regE, regHL),
	0x5F: makeLD(regE, regA),
	0x60: makeLD(regH, regB),
	0x61: makeLD(regH, regC),
	0x62: makeLD(regH, regD),
	0x63: makeLD(regH, regE),
	0x64: makeLD(regH, regH),
	0x65: makeLD(regH, regL),
	0x66: makeLDFromMem(regH, regHL),
	0x67: makeLD(regH, regA),
	0x68: makeLD(regL, regB),
	0x69: makeLD(regL, regC),
	0x6A: makeLD(regL, regD),
	0x6B: makeLD(regL, regE),
	0x6C: makeLD(regL, regH),
	0x6D: makeLD(regL, regL),
	0x6E: makeLDFromMem(regL, regHL),
	0x6F: makeLD(regL, regA),
	0x70: makeLDToMem(regHL, regB),
	0x71: makeLDToMem(regHL, regC),
	0x72: makeLDToMem(regHL, regD),
	0x73: makeLDToMem(regHL, regE),
	0x74: makeLDToMem(regHL, regH),
	0x75: makeLDToMem(regHL, regL),
	0x76: halt,
	0x77: makeLDToMem(regHL, regA),
	0x78: makeLD(regA, regB),
	0x79: makeLD(regA, regC),
	0x7A: makeLD(regA, regD),
	0x7B: makeLD(regA, regE),
	0x7C: makeLD(regA, regH),
	0x7D: makeLD(regA, regL),
	0x7E: makeLDFromMem(regA, regHL),
	0x7F: makeLD(regA, regA),
	0x80: makeADD(regB),
	0x81: makeADD(regC),
	0x82: makeADD(regD),
	0x83: makeADD(regE),
	0x84: makeADD(regH),
	0x85: makeADD(regL),
	0x86: addFromMemHL,
	0x87: makeADD(regA),
	0x88: makeADC(regB),
	0x89: makeADC(regC),
	0x8A: makeADC(regD),
	0x8B: makeADC(regE),
	0x8C: makeADC(regH),
	0x8D: makeADC(regL),
	0x8E: adcFromMemHL,
	0x8F: makeADC(regA),
	0x90: makeSUB(regB),
	0x91: makeSUB(regC),
	0x92: makeSUB(regD),
	0x93: makeSUB(regE),
	0x94: makeSUB(regH),
	0x95: makeSUB(regL),
	0x96: subFromMemHL,
	0x97: makeSUB(regA),
	0x98: makeSBC(regB),
	0x99: makeSBC(regC),
	0x9A: makeSBC(regD),
	0x9B: makeSBC(regE),
	0x9C: makeSBC(regH),
	0x9D: makeSBC(regL),
	0x9E: sbcFromMemHL,
	0x9F: makeSBC(regA),
	0xA0: makeAND(regB),
	0xA1: makeAND(regC),
	0xA2: makeAND(regD),
	0xA3: makeAND(regE),
	0xA4: makeAND(regH),
	0xA5: makeAND(regL),
	0xA6: andFromMemHL,
	0xA7: makeAND(regA),
	0xA8: makeXOR(regB),
	0xA9: makeXOR(regC),
	0xAA: makeXOR(regD),
	0xAB: makeXOR(regE),
	0xAC: makeXOR(regH),
	0xAD: makeXOR(regL),
	0xAE: xorFromMemHL,
	0xAF: makeXOR(regA),
	0xB0: makeOR(regB),
	0xB1: makeOR(regC),
	0xB2: makeOR(regD),
	0xB3: makeOR(regE),
	0xB4: makeOR(regH),
	0xB5: makeOR(regL),
	0xB6: orFromMemHL,
	0xB7: makeOR(regA),
	0xB8: makeCP(regB),
	0xB9: makeCP(regC),
	0xBA: makeCP(regD),
	0xBB: makeCP(regE),
	0xBC: makeCP(regH),
	0xBD: makeCP(regL),
	0xBE: cpFromMemHL,
	0xBF: makeCP(regA),
	0xC0: makeRETIfFlag(zeroFlag, false),
	0xC1: makePOP(regBC),
	0xC2: makeJPIfFlag(zeroFlag, false),
	0xC3: jp,
	0xC4: makeCALLIfFlag(zeroFlag, false),
	0xC5: makePUSH(regBC),
	0xC6: add8BitImm,
	0xC7: makeRST(0x00),
	0xC8: makeRETIfFlag(zeroFlag, true),
	0xC9: ret,
	0xCA: makeJPIfFlag(zeroFlag, true),
	0xCB: cbOpcodeDispatcher,
	0xCC: makeCALLIfFlag(zeroFlag, true),
	0xCD: call,
	0xCE: adc8BitImm,
	0xCF: makeRST(0x08),
	0xD0: makeRETIfFlag(carryFlag, false),
	0xD1: makePOP(regDE),
	0xD2: makeJPIfFlag(carryFlag, false),
	0xD3: nil,
	0xD4: makeCALLIfFlag(carryFlag, false),
	0xD5: makePUSH(regDE),
	0xD6: sub8BitImm,
	0xD7: makeRST(0x10),
	0xD8: makeRETIfFlag(carryFlag, true),
	0xD9: reti,
	0xDA: makeJPIfFlag(carryFlag, true),
	0xDB: nil,
	0xDC: makeCALLIfFlag(carryFlag, true),
	0xDD: nil,
	0xDE: sbc8BitImm,
	0xDF: makeRST(0x18),
	0xE0: ldhToMem,
	0xE1: makePOP(regHL),
	0xE2: ldToMemC,
	0xE3: nil,
	0xE4: nil,
	0xE5: makePUSH(regHL),
	0xE6: and8BitImm,
	0xE7: makeRST(0x20),
	0xE8: addToSP,
	0xE9: jpToHL,
	0xEA: ldTo16BitImmMem,
	0xEB: nil,
	0xEC: nil,
	0xED: nil,
	0xEE: xor8BitImm,
	0xEF: makeRST(0x28),
	0xF0: ldhFromMem,
	0xF1: makePOP(regAF),
	0xF2: ldFromMemC,
	0xF3: di,
	0xF4: nil,
	0xF5: makePUSH(regAF),
	0xF6: or8BitImm,
	0xF7: makeRST(0x30),
	0xF8: ldhl,
	0xF9: ldHLToSP,
	0xFA: ldFrom16BitImmMem,
	0xFB: ei,
	0xFC: nil,
	0xFD: nil,
	0xFE: cp8BitImm,
	0xFF: makeRST(0x38),
}

var cbOpcodeMapper = []instruction{
	0x00: makeRLC(regB),
	0x01: makeRLC(regC),
	0x02: makeRLC(regD),
	0x03: makeRLC(regE),
	0x04: makeRLC(regH),
	0x05: makeRLC(regL),
	0x06: rlcMemHL,
	0x07: makeRLC(regA),
	0x08: makeRRC(regB),
	0x09: makeRRC(regC),
	0x0A: makeRRC(regD),
	0x0B: makeRRC(regE),
	0x0C: makeRRC(regH),
	0x0D: makeRRC(regL),
	0x0E: rrcMemHL,
	0x0F: makeRRC(regA),
	0x10: makeRL(regB),
	0x11: makeRL(regC),
	0x12: makeRL(regD),
	0x13: makeRL(regE),
	0x14: makeRL(regH),
	0x15: makeRL(regL),
	0x16: rlMemHL,
	0x17: makeRL(regA),
	0x18: makeRR(regB),
	0x19: makeRR(regC),
	0x1A: makeRR(regD),
	0x1B: makeRR(regE),
	0x1C: makeRR(regH),
	0x1D: makeRR(regL),
	0x1E: rrMemHL,
	0x1F: makeRR(regA),
	0x20: makeSLA(regB),
	0x21: makeSLA(regC),
	0x22: makeSLA(regD),
	0x23: makeSLA(regE),
	0x24: makeSLA(regH),
	0x25: makeSLA(regL),
	0x26: slaMemHL,
	0x27: makeSLA(regA),
	0x28: makeSRA(regB),
	0x29: makeSRA(regC),
	0x2A: makeSRA(regD),
	0x2B: makeSRA(regE),
	0x2C: makeSRA(regH),
	0x2D: makeSRA(regL),
	0x2E: sraMemHL,
	0x2F: makeSRA(regA),
	0x30: makeSWAP(regB),
	0x31: makeSWAP(regC),
	0x32: makeSWAP(regD),
	0x33: makeSWAP(regE),
	0x34: makeSWAP(regH),
	0x35: makeSWAP(regL),
	0x36: swapMemHL,
	0x37: makeSWAP(regA),
	0x38: makeSRL(regB),
	0x39: makeSRL(regC),
	0x3A: makeSRL(regD),
	0x3B: makeSRL(regE),
	0x3C: makeSRL(regH),
	0x3D: makeSRL(regL),
	0x3E: srlMemHL,
	0x3F: makeSRL(regA),
	0x40: makeBIT(0, regB),
	0x41: makeBIT(0, regC),
	0x42: makeBIT(0, regD),
	0x43: makeBIT(0, regE),
	0x44: makeBIT(0, regH),
	0x45: makeBIT(0, regL),
	0x46: makeBITMemHL(0),
	0x47: makeBIT(0, regA),
	0x48: makeBIT(1, regB),
	0x49: makeBIT(1, regC),
	0x4A: makeBIT(1, regD),
	0x4B: makeBIT(1, regE),
	0x4C: makeBIT(1, regH),
	0x4D: makeBIT(1, regL),
	0x4E: makeBITMemHL(1),
	0x4F: makeBIT(1, regA),
	0x50: makeBIT(2, regB),
	0x51: makeBIT(2, regC),
	0x52: makeBIT(2, regD),
	0x53: makeBIT(2, regE),
	0x54: makeBIT(2, regH),
	0x55: makeBIT(2, regL),
	0x56: makeBITMemHL(2),
	0x57: makeBIT(2, regA),
	0x58: makeBIT(3, regB),
	0x59: makeBIT(3, regC),
	0x5A: makeBIT(3, regD),
	0x5B: makeBIT(3, regE),
	0x5C: makeBIT(3, regH),
	0x5D: makeBIT(3, regL),
	0x5E: makeBITMemHL(3),
	0x5F: makeBIT(3, regA),
	0x60: makeBIT(4, regB),
	0x61: makeBIT(4, regC),
	0x62: makeBIT(4, regD),
	0x63: makeBIT(4, regE),
	0x64: makeBIT(4, regH),
	0x65: makeBIT(4, regL),
	0x66: makeBITMemHL(4),
	0x67: makeBIT(4, regA),
	0x68: makeBIT(5, regB),
	0x69: makeBIT(5, regC),
	0x6A: makeBIT(5, regD),
	0x6B: makeBIT(5, regE),
	0x6C: makeBIT(5, regH),
	0x6D: makeBIT(5, regL),
	0x6E: makeBITMemHL(5),
	0x6F: makeBIT(5, regA),
	0x70: makeBIT(6, regB),
	0x71: makeBIT(6, regC),
	0x72: makeBIT(6, regD),
	0x73: makeBIT(6, regE),
	0x74: makeBIT(6, regH),
	0x75: makeBIT(6, regL),
	0x76: makeBITMemHL(6),
	0x77: makeBIT(6, regA),
	0x78: makeBIT(7, regB),
	0x79: makeBIT(7, regC),
	0x7A: makeBIT(7, regD),
	0x7B: makeBIT(7, regE),
	0x7C: makeBIT(7, regH),
	0x7D: makeBIT(7, regL),
	0x7E: makeBITMemHL(7),
	0x7F: makeBIT(7, regA),
	0x80: makeRES(0, regB),
	0x81: makeRES(0, regC),
	0x82: makeRES(0, regD),
	0x83: makeRES(0, regE),
	0x84: makeRES(0, regH),
	0x85: makeRES(0, regL),
	0x86: makeRESMemHL(0),
	0x87: makeRES(0, regA),
	0x88: makeRES(1, regB),
	0x89: makeRES(1, regC),
	0x8A: makeRES(1, regD),
	0x8B: makeRES(1, regE),
	0x8C: makeRES(1, regH),
	0x8D: makeRES(1, regL),
	0x8E: makeRESMemHL(1),
	0x8F: makeRES(1, regA),
	0x90: makeRES(2, regB),
	0x91: makeRES(2, regC),
	0x92: makeRES(2, regD),
	0x93: makeRES(2, regE),
	0x94: makeRES(2, regH),
	0x95: makeRES(2, regL),
	0x96: makeRESMemHL(2),
	0x97: makeRES(2, regA),
	0x98: makeRES(3, regB),
	0x99: makeRES(3, regC),
	0x9A: makeRES(3, regD),
	0x9B: makeRES(3, regE),
	0x9C: makeRES(3, regH),
	0x9D: makeRES(3, regL),
	0x9E: makeRESMemHL(3),
	0x9F: makeRES(3, regA),
	0xA0: makeRES(4, regB),
	0xA1: makeRES(4, regC),
	0xA2: makeRES(4, regD),
	0xA3: makeRES(4, regE),
	0xA4: makeRES(4, regH),
	0xA5: makeRES(4, regL),
	0xA6: makeRESMemHL(4),
	0xA7: makeRES(4, regA),
	0xA8: makeRES(5, regB),
	0xA9: makeRES(5, regC),
	0xAA: makeRES(5, regD),
	0xAB: makeRES(5, regE),
	0xAC: makeRES(5, regH),
	0xAD: makeRES(5, regL),
	0xAE: makeRESMemHL(5),
	0xAF: makeRES(5, regA),
	0xB0: makeRES(6, regB),
	0xB1: makeRES(6, regC),
	0xB2: makeRES(6, regD),
	0xB3: makeRES(6, regE),
	0xB4: makeRES(6, regH),
	0xB5: makeRES(6, regL),
	0xB6: makeRESMemHL(6),
	0xB7: makeRES(6, regA),
	0xB8: makeRES(7, regB),
	0xB9: makeRES(7, regC),
	0xBA: makeRES(7, regD),
	0xBB: makeRES(7, regE),
	0xBC: makeRES(7, regH),
	0xBD: makeRES(7, regL),
	0xBE: makeRESMemHL(7),
	0xBF: makeRES(7, regA),
	0xC0: makeSET(0, regB),
	0xC1: makeSET(0, regC),
	0xC2: makeSET(0, regD),
	0xC3: makeSET(0, regE),
	0xC4: makeSET(0, regH),
	0xC5: makeSET(0, regL),
	0xC6: makeSETMemHL(0),
	0xC7: makeSET(0, regA),
	0xC8: makeSET(1, regB),
	0xC9: makeSET(1, regC),
	0xCA: makeSET(1, regD),
	0xCB: makeSET(1, regE),
	0xCC: makeSET(1, regH),
	0xCD: makeSET(1, regL),
	0xCE: makeSETMemHL(1),
	0xCF: makeSET(1, regA),
	0xD0: makeSET(2, regB),
	0xD1: makeSET(2, regC),
	0xD2: makeSET(2, regD),
	0xD3: makeSET(2, regE),
	0xD4: makeSET(2, regH),
	0xD5: makeSET(2, regL),
	0xD6: makeSETMemHL(2),
	0xD7: makeSET(2, regA),
	0xD8: makeSET(3, regB),
	0xD9: makeSET(3, regC),
	0xDA: makeSET(3, regD),
	0xDB: makeSET(3, regE),
	0xDC: makeSET(3, regH),
	0xDD: makeSET(3, regL),
	0xDE: makeSETMemHL(3),
	0xDF: makeSET(3, regA),
	0xE0: makeSET(4, regB),
	0xE1: makeSET(4, regC),
	0xE2: makeSET(4, regD),
	0xE3: makeSET(4, regE),
	0xE4: makeSET(4, regH),
	0xE5: makeSET(4, regL),
	0xE6: makeSETMemHL(4),
	0xE7: makeSET(4, regA),
	0xE8: makeSET(5, regB),
	0xE9: makeSET(5, regC),
	0xEA: makeSET(5, regD),
	0xEB: makeSET(5, regE),
	0xEC: makeSET(5, regH),
	0xED: makeSET(5, regL),
	0xEE: makeSETMemHL(5),
	0xEF: makeSET(5, regA),
	0xF0: makeSET(6, regB),
	0xF1: makeSET(6, regC),
	0xF2: makeSET(6, regD),
	0xF3: makeSET(6, regE),
	0xF4: makeSET(6, regH),
	0xF5: makeSET(6, regL),
	0xF6: makeSETMemHL(6),
	0xF7: makeSET(6, regA),
	0xF8: makeSET(7, regB),
	0xF9: makeSET(7, regC),
	0xFA: makeSET(7, regD),
	0xFB: makeSET(7, regE),
	0xFC: makeSET(7, regH),
	0xFD: makeSET(7, regL),
	0xFE: makeSETMemHL(7),
	0xFF: makeSET(7, regA),
}

// runOpcode runs the operation that maps to the given opcode.
func runOpcode(state *State, opcode uint8) (cycles int, err error) {
	if printInstructions {
		fmt.Printf("@PC %#x | %#x: ", state.instructionStart, opcode)
	}

	instr := opcodeMapper[opcode]
	if instr == nil {
		return 0, xerrors.Errorf("unknown opcode %#x", opcode)
	}
	return instr(state), nil
}

// cbOpcodeDispatcher pops the next opcode from the program counter and
// dispatches the corresponding CB instruction.
func cbOpcodeDispatcher(state *State) int {
	cbOpcode := state.incrementPC()

	instr := cbOpcodeMapper[cbOpcode]
	return instr(state)
}

// getConditionalStr creates a string representation of a conditional flag
// check.
func getConditionalStr(flagMask uint8, isSet bool) string {
	var conditional string
	switch flagMask {
	case zeroFlag:
		conditional = "Z"
	case carryFlag:
		conditional = "C"
	default:
		panic("unsupported JR conditional flag")
	}
	if !isSet {
		conditional = "N" + conditional
	}

	return conditional
}
