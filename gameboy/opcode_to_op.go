package gameboy

import (
	"fmt"
)

// TODO(velovix): Document what instructions do to flags

// instruction is a function will run a CPU instruction operation and return
// the time in CPU cycles that the instruction took.
type instruction func(*State) int

// opcodeMapper is a lookup table that links opcodes to the corresponding
// instructions.
var opcodeMapper = []instruction{
	0x00: nop,
	0x01: ld16BitImm(regBC),
	0x02: ldToMem(regBC, regA),
	0x03: inc16Bit(regBC),
	0x04: inc8Bit(regB),
	0x05: dec8Bit(regB),
	0x06: ld8BitImm(regB),
	0x07: rlca,
	0x08: ldSPToMem,
	0x09: addToHL(regBC),
	0x0A: ldFromMem(regA, regBC),
	0x0B: dec16Bit(regBC),
	0x0C: inc8Bit(regC),
	0x0D: dec8Bit(regC),
	0x0E: ld8BitImm(regC),
	0x0F: rrca,
	0x10: stop,
	0x11: ld16BitImm(regDE),
	0x12: ldToMem(regDE, regA),
	0x13: inc16Bit(regDE),
	0x14: inc8Bit(regD),
	0x15: dec8Bit(regD),
	0x16: ld8BitImm(regD),
	0x17: rla,
	0x18: jr,
	0x19: addToHL(regDE),
	0x1A: ldFromMem(regA, regDE),
	0x1B: dec16Bit(regDE),
	0x1C: inc8Bit(regE),
	0x1D: dec8Bit(regE),
	0x1E: ld8BitImm(regE),
	0x1F: rra,
	0x20: jrIfFlag(zeroFlag, false),
	0x21: ld16BitImm(regHL),
	0x22: ldiToMem,
	0x23: inc16Bit(regHL),
	0x24: inc8Bit(regH),
	0x25: dec8Bit(regH),
	0x26: ld8BitImm(regH),
	0x27: daa,
	0x28: jrIfFlag(zeroFlag, true),
	0x29: addToHL(regHL),
	0x2A: ldiFromMem,
	0x2B: dec16Bit(regHL),
	0x2C: inc8Bit(regL),
	0x2D: dec8Bit(regL),
	0x2E: ld8BitImm(regL),
	0x2F: cpl,
	0x30: jrIfFlag(carryFlag, false),
	0x31: ld16BitImm(regSP),
	0x32: lddToMem,
	0x33: inc16Bit(regSP),
	0x34: incMemHL,
	0x35: decMemHL,
	0x36: ld8BitImmToMemHL,
	0x37: scf,
	0x38: jrIfFlag(carryFlag, true),
	0x39: addToHL(regSP),
	0x3A: lddFromMem,
	0x3B: dec16Bit(regSP),
	0x3C: inc8Bit(regA),
	0x3D: dec8Bit(regA),
	0x3E: ld8BitImm(regA),
	0x3F: ccf,
	0x40: ld(regB, regB),
	0x41: ld(regB, regC),
	0x42: ld(regB, regD),
	0x43: ld(regB, regE),
	0x44: ld(regB, regH),
	0x45: ld(regB, regL),
	0x46: ldFromMem(regB, regHL),
	0x47: ld(regB, regA),
	0x48: ld(regC, regB),
	0x49: ld(regC, regC),
	0x4A: ld(regC, regD),
	0x4B: ld(regC, regE),
	0x4C: ld(regC, regH),
	0x4D: ld(regC, regL),
	0x4E: ldFromMem(regC, regHL),
	0x4F: ld(regC, regA),
	0x50: ld(regD, regB),
	0x51: ld(regD, regC),
	0x52: ld(regD, regD),
	0x53: ld(regD, regE),
	0x54: ld(regD, regH),
	0x55: ld(regD, regL),
	0x56: ldFromMem(regD, regHL),
	0x57: ld(regD, regA),
	0x58: ld(regE, regB),
	0x59: ld(regE, regC),
	0x5A: ld(regE, regD),
	0x5B: ld(regE, regE),
	0x5C: ld(regE, regH),
	0x5D: ld(regE, regL),
	0x5E: ldFromMem(regE, regHL),
	0x5F: ld(regE, regA),
	0x60: ld(regH, regB),
	0x61: ld(regH, regC),
	0x62: ld(regH, regD),
	0x63: ld(regH, regE),
	0x64: ld(regH, regH),
	0x65: ld(regH, regL),
	0x66: ldFromMem(regH, regHL),
	0x67: ld(regH, regA),
	0x68: ld(regL, regB),
	0x69: ld(regL, regC),
	0x6A: ld(regL, regD),
	0x6B: ld(regL, regE),
	0x6C: ld(regL, regH),
	0x6D: ld(regL, regL),
	0x6E: ldFromMem(regL, regHL),
	0x6F: ld(regL, regA),
	0x70: ldToMem(regHL, regB),
	0x71: ldToMem(regHL, regC),
	0x72: ldToMem(regHL, regD),
	0x73: ldToMem(regHL, regE),
	0x74: ldToMem(regHL, regH),
	0x75: ldToMem(regHL, regL),
	0x76: halt,
	0x77: ldToMem(regHL, regA),
	0x78: ld(regA, regB),
	0x79: ld(regA, regC),
	0x7A: ld(regA, regD),
	0x7B: ld(regA, regE),
	0x7C: ld(regA, regH),
	0x7D: ld(regA, regL),
	0x7E: ldFromMem(regA, regHL),
	0x7F: ld(regA, regA),
	0x80: add(regB),
	0x81: add(regC),
	0x82: add(regD),
	0x83: add(regE),
	0x84: add(regH),
	0x85: add(regL),
	0x86: addFromMemHL,
	0x87: add(regA),
	0x88: adc(regB),
	0x89: adc(regC),
	0x8A: adc(regD),
	0x8B: adc(regE),
	0x8C: adc(regH),
	0x8D: adc(regL),
	0x8E: adcFromMemHL,
	0x8F: adc(regA),
	0x90: sub(regB),
	0x91: sub(regC),
	0x92: sub(regD),
	0x93: sub(regE),
	0x94: sub(regH),
	0x95: sub(regL),
	0x96: subFromMemHL,
	0x97: sub(regA),
	0x98: sbc(regB),
	0x99: sbc(regC),
	0x9A: sbc(regD),
	0x9B: sbc(regE),
	0x9C: sbc(regH),
	0x9D: sbc(regL),
	0x9E: sbcFromMemHL,
	0x9F: sbc(regA),
	0xA0: and(regB),
	0xA1: and(regC),
	0xA2: and(regD),
	0xA3: and(regE),
	0xA4: and(regH),
	0xA5: and(regL),
	0xA6: andFromMemHL,
	0xA7: and(regA),
	0xA8: xor(regB),
	0xA9: xor(regC),
	0xAA: xor(regD),
	0xAB: xor(regE),
	0xAC: xor(regH),
	0xAD: xor(regL),
	0xAE: xorFromMemHL,
	0xAF: xor(regA),
	0xB0: or(regB),
	0xB1: or(regC),
	0xB2: or(regD),
	0xB3: or(regE),
	0xB4: or(regH),
	0xB5: or(regL),
	0xB6: orFromMemHL,
	0xB7: or(regA),
	0xB8: cp(regB),
	0xB9: cp(regC),
	0xBA: cp(regD),
	0xBB: cp(regE),
	0xBC: cp(regH),
	0xBD: cp(regL),
	0xBE: cpFromMemHL,
	0xBF: cp(regA),
	0xC0: retIfFlag(zeroFlag, false),
	0xC1: pop(regBC),
	0xC2: jpIfFlag(zeroFlag, false),
	0xC3: jp,
	0xC4: callIfFlag(zeroFlag, false),
	0xC5: push(regBC),
	0xC6: add8BitImm,
	0xC7: rst(0x00),
	0xC8: retIfFlag(zeroFlag, true),
	0xC9: ret,
	0xCA: jpIfFlag(zeroFlag, true),
	0xCB: cbOpcodeDispatcher,
	0xCC: callIfFlag(zeroFlag, true),
	0xCD: call,
	0xCE: adc8BitImm,
	0xCF: rst(0x08),
	0xD0: retIfFlag(carryFlag, false),
	0xD1: pop(regDE),
	0xD2: jpIfFlag(carryFlag, false),
	0xD3: nil,
	0xD4: callIfFlag(carryFlag, false),
	0xD5: push(regDE),
	0xD6: sub8BitImm,
	0xD7: rst(0x10),
	0xD8: retIfFlag(carryFlag, true),
	0xD9: reti,
	0xDA: jpIfFlag(carryFlag, true),
	0xDB: nil,
	0xDC: callIfFlag(carryFlag, true),
	0xDD: nil,
	0xDE: sbc8BitImm,
	0xDF: rst(0x18),
	0xE0: ldhToMem,
	0xE1: pop(regHL),
	0xE2: ldToMemC,
	0xE3: nil,
	0xE4: nil,
	0xE5: push(regHL),
	0xE6: and8BitImm,
	0xE7: rst(0x20),
	0xE8: addToSP,
	0xE9: jpToHL,
	0xEA: ldTo16BitImmMem,
	0xEB: nil,
	0xEC: nil,
	0xED: nil,
	0xEE: xor8BitImm,
	0xEF: rst(0x28),
	0xF0: ldhFromMem,
	0xF1: pop(regAF),
	0xF2: ldFromMemC,
	0xF3: di,
	0xF4: nil,
	0xF5: push(regAF),
	0xF6: or8BitImm,
	0xF7: rst(0x30),
	0xF8: ldhl,
	0xF9: ldHLToSP,
	0xFA: ldFrom16BitImmMem,
	0xFB: ei,
	0xFC: nil,
	0xFD: nil,
	0xFE: cp8BitImm,
	0xFF: rst(0x38),
}

var cbOpcodeMapper = []instruction{
	0x00: rlc(regB),
	0x01: rlc(regC),
	0x02: rlc(regD),
	0x03: rlc(regE),
	0x04: rlc(regH),
	0x05: rlc(regL),
	0x06: rlcMemHL,
	0x07: rlc(regA),
	0x08: rrc(regB),
	0x09: rrc(regC),
	0x0A: rrc(regD),
	0x0B: rrc(regE),
	0x0C: rrc(regH),
	0x0D: rrc(regL),
	0x0E: rrcMemHL,
	0x0F: rrc(regA),
	0x10: rl(regB),
	0x11: rl(regC),
	0x12: rl(regD),
	0x13: rl(regE),
	0x14: rl(regH),
	0x15: rl(regL),
	0x16: rlMemHL,
	0x17: rl(regA),
	0x18: rr(regB),
	0x19: rr(regC),
	0x1A: rr(regD),
	0x1B: rr(regE),
	0x1C: rr(regH),
	0x1D: rr(regL),
	0x1E: rrMemHL,
	0x1F: rr(regA),
	0x20: sla(regB),
	0x21: sla(regC),
	0x22: sla(regD),
	0x23: sla(regE),
	0x24: sla(regH),
	0x25: sla(regL),
	0x26: slaMemHL,
	0x27: sla(regA),
	0x28: sra(regB),
	0x29: sra(regC),
	0x2A: sra(regD),
	0x2B: sra(regE),
	0x2C: sra(regH),
	0x2D: sra(regL),
	0x2E: sraMemHL,
	0x2F: sra(regA),
	0x30: swap(regB),
	0x31: swap(regC),
	0x32: swap(regD),
	0x33: swap(regE),
	0x34: swap(regH),
	0x35: swap(regL),
	0x36: swapMemHL,
	0x37: swap(regA),
	0x38: srl(regB),
	0x39: srl(regC),
	0x3A: srl(regD),
	0x3B: srl(regE),
	0x3C: srl(regH),
	0x3D: srl(regL),
	0x3E: srlMemHL,
	0x3F: srl(regA),
	0x40: bit(0, regB),
	0x41: bit(0, regC),
	0x42: bit(0, regD),
	0x43: bit(0, regE),
	0x44: bit(0, regH),
	0x45: bit(0, regL),
	0x46: bitMemHL(0),
	0x47: bit(0, regA),
	0x48: bit(1, regB),
	0x49: bit(1, regC),
	0x4A: bit(1, regD),
	0x4B: bit(1, regE),
	0x4C: bit(1, regH),
	0x4D: bit(1, regL),
	0x4E: bitMemHL(1),
	0x4F: bit(1, regA),
	0x50: bit(2, regB),
	0x51: bit(2, regC),
	0x52: bit(2, regD),
	0x53: bit(2, regE),
	0x54: bit(2, regH),
	0x55: bit(2, regL),
	0x56: bitMemHL(2),
	0x57: bit(2, regA),
	0x58: bit(3, regB),
	0x59: bit(3, regC),
	0x5A: bit(3, regD),
	0x5B: bit(3, regE),
	0x5C: bit(3, regH),
	0x5D: bit(3, regL),
	0x5E: bitMemHL(3),
	0x5F: bit(3, regA),
	0x60: bit(4, regB),
	0x61: bit(4, regC),
	0x62: bit(4, regD),
	0x63: bit(4, regE),
	0x64: bit(4, regH),
	0x65: bit(4, regL),
	0x66: bitMemHL(4),
	0x67: bit(4, regA),
	0x68: bit(5, regB),
	0x69: bit(5, regC),
	0x6A: bit(5, regD),
	0x6B: bit(5, regE),
	0x6C: bit(5, regH),
	0x6D: bit(5, regL),
	0x6E: bitMemHL(5),
	0x6F: bit(5, regA),
	0x70: bit(6, regB),
	0x71: bit(6, regC),
	0x72: bit(6, regD),
	0x73: bit(6, regE),
	0x74: bit(6, regH),
	0x75: bit(6, regL),
	0x76: bitMemHL(6),
	0x77: bit(6, regA),
	0x78: bit(7, regB),
	0x79: bit(7, regC),
	0x7A: bit(7, regD),
	0x7B: bit(7, regE),
	0x7C: bit(7, regH),
	0x7D: bit(7, regL),
	0x7E: bitMemHL(7),
	0x7F: bit(7, regA),
	0x80: res(0, regB),
	0x81: res(0, regC),
	0x82: res(0, regD),
	0x83: res(0, regE),
	0x84: res(0, regH),
	0x85: res(0, regL),
	0x86: resMemHL(0),
	0x87: res(0, regA),
	0x88: res(1, regB),
	0x89: res(1, regC),
	0x8A: res(1, regD),
	0x8B: res(1, regE),
	0x8C: res(1, regH),
	0x8D: res(1, regL),
	0x8E: resMemHL(1),
	0x8F: res(1, regA),
	0x90: res(2, regB),
	0x91: res(2, regC),
	0x92: res(2, regD),
	0x93: res(2, regE),
	0x94: res(2, regH),
	0x95: res(2, regL),
	0x96: resMemHL(2),
	0x97: res(2, regA),
	0x98: res(3, regB),
	0x99: res(3, regC),
	0x9A: res(3, regD),
	0x9B: res(3, regE),
	0x9C: res(3, regH),
	0x9D: res(3, regL),
	0x9E: resMemHL(3),
	0x9F: res(3, regA),
	0xA0: res(4, regB),
	0xA1: res(4, regC),
	0xA2: res(4, regD),
	0xA3: res(4, regE),
	0xA4: res(4, regH),
	0xA5: res(4, regL),
	0xA6: resMemHL(4),
	0xA7: res(4, regA),
	0xA8: res(5, regB),
	0xA9: res(5, regC),
	0xAA: res(5, regD),
	0xAB: res(5, regE),
	0xAC: res(5, regH),
	0xAD: res(5, regL),
	0xAE: resMemHL(5),
	0xAF: res(5, regA),
	0xB0: res(6, regB),
	0xB1: res(6, regC),
	0xB2: res(6, regD),
	0xB3: res(6, regE),
	0xB4: res(6, regH),
	0xB5: res(6, regL),
	0xB6: resMemHL(6),
	0xB7: res(6, regA),
	0xB8: res(7, regB),
	0xB9: res(7, regC),
	0xBA: res(7, regD),
	0xBB: res(7, regE),
	0xBC: res(7, regH),
	0xBD: res(7, regL),
	0xBE: resMemHL(7),
	0xBF: res(7, regA),
	0xC0: set(0, regB),
	0xC1: set(0, regC),
	0xC2: set(0, regD),
	0xC3: set(0, regE),
	0xC4: set(0, regH),
	0xC5: set(0, regL),
	0xC6: setMemHL(0),
	0xC7: set(0, regA),
	0xC8: set(1, regB),
	0xC9: set(1, regC),
	0xCA: set(1, regD),
	0xCB: set(1, regE),
	0xCC: set(1, regH),
	0xCD: set(1, regL),
	0xCE: setMemHL(1),
	0xCF: set(1, regA),
	0xD0: set(2, regB),
	0xD1: set(2, regC),
	0xD2: set(2, regD),
	0xD3: set(2, regE),
	0xD4: set(2, regH),
	0xD5: set(2, regL),
	0xD6: setMemHL(2),
	0xD7: set(2, regA),
	0xD8: set(3, regB),
	0xD9: set(3, regC),
	0xDA: set(3, regD),
	0xDB: set(3, regE),
	0xDC: set(3, regH),
	0xDD: set(3, regL),
	0xDE: setMemHL(3),
	0xDF: set(3, regA),
	0xE0: set(4, regB),
	0xE1: set(4, regC),
	0xE2: set(4, regD),
	0xE3: set(4, regE),
	0xE4: set(4, regH),
	0xE5: set(4, regL),
	0xE6: setMemHL(4),
	0xE7: set(4, regA),
	0xE8: set(5, regB),
	0xE9: set(5, regC),
	0xEA: set(5, regD),
	0xEB: set(5, regE),
	0xEC: set(5, regH),
	0xED: set(5, regL),
	0xEE: setMemHL(5),
	0xEF: set(5, regA),
	0xF0: set(6, regB),
	0xF1: set(6, regC),
	0xF2: set(6, regD),
	0xF3: set(6, regE),
	0xF4: set(6, regH),
	0xF5: set(6, regL),
	0xF6: setMemHL(6),
	0xF7: set(6, regA),
	0xF8: set(7, regB),
	0xF9: set(7, regC),
	0xFA: set(7, regD),
	0xFB: set(7, regE),
	0xFC: set(7, regH),
	0xFD: set(7, regL),
	0xFE: setMemHL(7),
	0xFF: set(7, regA),
}

// runOpcode runs the operation that maps to the given opcode.
func runOpcode(state *State, opcode uint8) (cycles int, err error) {
	if printInstructions {
		fmt.Printf("@PC %#x | %#x: ", state.instructionStart, opcode)
	}

	instr := opcodeMapper[opcode]
	if instr == nil {
		return 0, fmt.Errorf("unknown opcode %#x", opcode)
	}
	return instr(state), nil
}

// cbOpcodeDispatcher pops the next opcode from the program counter and
// dispatches the corresponding CB instruction.
func cbOpcodeDispatcher(state *State) int {
	cbOpcode := state.incrementPC()

	instr := cbOpcodeMapper[cbOpcode]
	return instr(state)
}

// getConditionalStr creates a string representation of a conditional flag
// check.
func getConditionalStr(flagMask uint8, isSet bool) string {
	var conditional string
	switch flagMask {
	case zeroFlag:
		conditional = "Z"
	case carryFlag:
		conditional = "C"
	default:
		panic("unsupported JR conditional flag")
	}
	if !isSet {
		conditional = "N" + conditional
	}

	return conditional
}
